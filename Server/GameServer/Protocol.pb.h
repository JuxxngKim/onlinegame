// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_Chat;
struct C_ChatDefaultTypeInternal;
extern C_ChatDefaultTypeInternal _C_Chat_default_instance_;
class C_CreateAccount;
struct C_CreateAccountDefaultTypeInternal;
extern C_CreateAccountDefaultTypeInternal _C_CreateAccount_default_instance_;
class C_EnterGame;
struct C_EnterGameDefaultTypeInternal;
extern C_EnterGameDefaultTypeInternal _C_EnterGame_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_Pong;
struct C_PongDefaultTypeInternal;
extern C_PongDefaultTypeInternal _C_Pong_default_instance_;
class C_Skill;
struct C_SkillDefaultTypeInternal;
extern C_SkillDefaultTypeInternal _C_Skill_default_instance_;
class S_ChangeHp;
struct S_ChangeHpDefaultTypeInternal;
extern S_ChangeHpDefaultTypeInternal _S_ChangeHp_default_instance_;
class S_ChangeStat;
struct S_ChangeStatDefaultTypeInternal;
extern S_ChangeStatDefaultTypeInternal _S_ChangeStat_default_instance_;
class S_Chat;
struct S_ChatDefaultTypeInternal;
extern S_ChatDefaultTypeInternal _S_Chat_default_instance_;
class S_Connected;
struct S_ConnectedDefaultTypeInternal;
extern S_ConnectedDefaultTypeInternal _S_Connected_default_instance_;
class S_CreateAccount;
struct S_CreateAccountDefaultTypeInternal;
extern S_CreateAccountDefaultTypeInternal _S_CreateAccount_default_instance_;
class S_Despawn;
struct S_DespawnDefaultTypeInternal;
extern S_DespawnDefaultTypeInternal _S_Despawn_default_instance_;
class S_Die;
struct S_DieDefaultTypeInternal;
extern S_DieDefaultTypeInternal _S_Die_default_instance_;
class S_EnterGame;
struct S_EnterGameDefaultTypeInternal;
extern S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
class S_LeaveGame;
struct S_LeaveGameDefaultTypeInternal;
extern S_LeaveGameDefaultTypeInternal _S_LeaveGame_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_Ping;
struct S_PingDefaultTypeInternal;
extern S_PingDefaultTypeInternal _S_Ping_default_instance_;
class S_Skill;
struct S_SkillDefaultTypeInternal;
extern S_SkillDefaultTypeInternal _S_Skill_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_Chat* Arena::CreateMaybeMessage<::Protocol::C_Chat>(Arena*);
template<> ::Protocol::C_CreateAccount* Arena::CreateMaybeMessage<::Protocol::C_CreateAccount>(Arena*);
template<> ::Protocol::C_EnterGame* Arena::CreateMaybeMessage<::Protocol::C_EnterGame>(Arena*);
template<> ::Protocol::C_Login* Arena::CreateMaybeMessage<::Protocol::C_Login>(Arena*);
template<> ::Protocol::C_Move* Arena::CreateMaybeMessage<::Protocol::C_Move>(Arena*);
template<> ::Protocol::C_Pong* Arena::CreateMaybeMessage<::Protocol::C_Pong>(Arena*);
template<> ::Protocol::C_Skill* Arena::CreateMaybeMessage<::Protocol::C_Skill>(Arena*);
template<> ::Protocol::S_ChangeHp* Arena::CreateMaybeMessage<::Protocol::S_ChangeHp>(Arena*);
template<> ::Protocol::S_ChangeStat* Arena::CreateMaybeMessage<::Protocol::S_ChangeStat>(Arena*);
template<> ::Protocol::S_Chat* Arena::CreateMaybeMessage<::Protocol::S_Chat>(Arena*);
template<> ::Protocol::S_Connected* Arena::CreateMaybeMessage<::Protocol::S_Connected>(Arena*);
template<> ::Protocol::S_CreateAccount* Arena::CreateMaybeMessage<::Protocol::S_CreateAccount>(Arena*);
template<> ::Protocol::S_Despawn* Arena::CreateMaybeMessage<::Protocol::S_Despawn>(Arena*);
template<> ::Protocol::S_Die* Arena::CreateMaybeMessage<::Protocol::S_Die>(Arena*);
template<> ::Protocol::S_EnterGame* Arena::CreateMaybeMessage<::Protocol::S_EnterGame>(Arena*);
template<> ::Protocol::S_LeaveGame* Arena::CreateMaybeMessage<::Protocol::S_LeaveGame>(Arena*);
template<> ::Protocol::S_Login* Arena::CreateMaybeMessage<::Protocol::S_Login>(Arena*);
template<> ::Protocol::S_Move* Arena::CreateMaybeMessage<::Protocol::S_Move>(Arena*);
template<> ::Protocol::S_Ping* Arena::CreateMaybeMessage<::Protocol::S_Ping>(Arena*);
template<> ::Protocol::S_Skill* Arena::CreateMaybeMessage<::Protocol::S_Skill>(Arena*);
template<> ::Protocol::S_Spawn* Arena::CreateMaybeMessage<::Protocol::S_Spawn>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class S_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGame) */ {
 public:
  inline S_EnterGame() : S_EnterGame(nullptr) {}
  ~S_EnterGame() override;
  explicit constexpr S_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGame(const S_EnterGame& from);
  S_EnterGame(S_EnterGame&& from) noexcept
    : S_EnterGame() {
    *this = ::std::move(from);
  }

  inline S_EnterGame& operator=(const S_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGame& operator=(S_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGame* internal_default_instance() {
    return reinterpret_cast<const S_EnterGame*>(
               &_S_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_EnterGame& a, S_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_EnterGame* New() const final {
    return new S_EnterGame();
  }

  S_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_EnterGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_EnterGame& from);
  void MergeFrom(const S_EnterGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGame";
  }
  protected:
  explicit S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LeaveGame) */ {
 public:
  inline S_LeaveGame() : S_LeaveGame(nullptr) {}
  ~S_LeaveGame() override;
  explicit constexpr S_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveGame(const S_LeaveGame& from);
  S_LeaveGame(S_LeaveGame&& from) noexcept
    : S_LeaveGame() {
    *this = ::std::move(from);
  }

  inline S_LeaveGame& operator=(const S_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveGame& operator=(S_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const S_LeaveGame*>(
               &_S_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LeaveGame& a, S_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_LeaveGame* New() const final {
    return new S_LeaveGame();
  }

  S_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_LeaveGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_LeaveGame& from);
  void MergeFrom(const S_LeaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LeaveGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LeaveGame";
  }
  protected:
  explicit S_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  explicit constexpr S_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Spawn(const S_Spawn& from);
  S_Spawn(S_Spawn&& from) noexcept
    : S_Spawn() {
    *this = ::std::move(from);
  }

  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
               &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_Spawn& a, S_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Spawn* New() const final {
    return new S_Spawn();
  }

  S_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Spawn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Spawn& from);
  void MergeFrom(const S_Spawn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Spawn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Spawn";
  }
  protected:
  explicit S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::Protocol::ObjectInfo* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objects();
  private:
  const ::Protocol::ObjectInfo& _internal_objects(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objects();
  public:
  const ::Protocol::ObjectInfo& objects(int index) const;
  ::Protocol::ObjectInfo* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objects_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Despawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Despawn) */ {
 public:
  inline S_Despawn() : S_Despawn(nullptr) {}
  ~S_Despawn() override;
  explicit constexpr S_Despawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Despawn(const S_Despawn& from);
  S_Despawn(S_Despawn&& from) noexcept
    : S_Despawn() {
    *this = ::std::move(from);
  }

  inline S_Despawn& operator=(const S_Despawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Despawn& operator=(S_Despawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Despawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Despawn* internal_default_instance() {
    return reinterpret_cast<const S_Despawn*>(
               &_S_Despawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_Despawn& a, S_Despawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Despawn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Despawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Despawn* New() const final {
    return new S_Despawn();
  }

  S_Despawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Despawn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Despawn& from);
  void MergeFrom(const S_Despawn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Despawn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Despawn";
  }
  protected:
  explicit S_Despawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated int32 objectIds = 1;
  int objectids_size() const;
  private:
  int _internal_objectids_size() const;
  public:
  void clear_objectids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_objectids() const;
  void _internal_add_objectids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_objectids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 objectids(int index) const;
  void set_objectids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_objectids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      objectids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_objectids();

  // @@protoc_insertion_point(class_scope:Protocol.S_Despawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > objectids_;
  mutable std::atomic<int> _objectids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit constexpr C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Move* New() const final {
    return new C_Move();
  }

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Move& from);
  void MergeFrom(const C_Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PositionInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit constexpr S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Move* New() const final {
    return new S_Move();
  }

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Move& from);
  void MergeFrom(const S_Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // int32 objectId = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::int32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectid() const;
  void _internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PositionInfo* posinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Skill) */ {
 public:
  inline C_Skill() : C_Skill(nullptr) {}
  ~C_Skill() override;
  explicit constexpr C_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Skill(const C_Skill& from);
  C_Skill(C_Skill&& from) noexcept
    : C_Skill() {
    *this = ::std::move(from);
  }

  inline C_Skill& operator=(const C_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Skill& operator=(C_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Skill* internal_default_instance() {
    return reinterpret_cast<const C_Skill*>(
               &_C_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_Skill& a, C_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Skill* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Skill* New() const final {
    return new C_Skill();
  }

  C_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Skill>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Skill& from);
  void MergeFrom(const C_Skill& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Skill* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Skill";
  }
  protected:
  explicit C_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::SkillInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Skill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Skill) */ {
 public:
  inline S_Skill() : S_Skill(nullptr) {}
  ~S_Skill() override;
  explicit constexpr S_Skill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Skill(const S_Skill& from);
  S_Skill(S_Skill&& from) noexcept
    : S_Skill() {
    *this = ::std::move(from);
  }

  inline S_Skill& operator=(const S_Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Skill& operator=(S_Skill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Skill& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Skill* internal_default_instance() {
    return reinterpret_cast<const S_Skill*>(
               &_S_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_Skill& a, S_Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Skill* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Skill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Skill* New() const final {
    return new S_Skill();
  }

  S_Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Skill>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Skill& from);
  void MergeFrom(const S_Skill& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Skill* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Skill";
  }
  protected:
  explicit S_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // int32 objectId = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::int32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectid() const;
  void _internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Skill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::SkillInfo* info_;
  ::PROTOBUF_NAMESPACE_ID::int32 objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeHp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeHp) */ {
 public:
  inline S_ChangeHp() : S_ChangeHp(nullptr) {}
  ~S_ChangeHp() override;
  explicit constexpr S_ChangeHp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeHp(const S_ChangeHp& from);
  S_ChangeHp(S_ChangeHp&& from) noexcept
    : S_ChangeHp() {
    *this = ::std::move(from);
  }

  inline S_ChangeHp& operator=(const S_ChangeHp& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeHp& operator=(S_ChangeHp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeHp& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeHp* internal_default_instance() {
    return reinterpret_cast<const S_ChangeHp*>(
               &_S_ChangeHp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_ChangeHp& a, S_ChangeHp& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeHp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeHp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ChangeHp* New() const final {
    return new S_ChangeHp();
  }

  S_ChangeHp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ChangeHp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ChangeHp& from);
  void MergeFrom(const S_ChangeHp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeHp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeHp";
  }
  protected:
  explicit S_ChangeHp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 objectId = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::int32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectid() const;
  void _internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hp = 2;
  void clear_hp();
  ::PROTOBUF_NAMESPACE_ID::int32 hp() const;
  void set_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hp() const;
  void _internal_set_hp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeHp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 objectid_;
  ::PROTOBUF_NAMESPACE_ID::int32 hp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Die final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Die) */ {
 public:
  inline S_Die() : S_Die(nullptr) {}
  ~S_Die() override;
  explicit constexpr S_Die(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Die(const S_Die& from);
  S_Die(S_Die&& from) noexcept
    : S_Die() {
    *this = ::std::move(from);
  }

  inline S_Die& operator=(const S_Die& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Die& operator=(S_Die&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Die& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Die* internal_default_instance() {
    return reinterpret_cast<const S_Die*>(
               &_S_Die_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_Die& a, S_Die& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Die* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Die* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Die* New() const final {
    return new S_Die();
  }

  S_Die* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Die>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Die& from);
  void MergeFrom(const S_Die& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Die* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Die";
  }
  protected:
  explicit S_Die(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
  };
  // int32 objectId = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::int32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectid() const;
  void _internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attackerId = 2;
  void clear_attackerid();
  ::PROTOBUF_NAMESPACE_ID::int32 attackerid() const;
  void set_attackerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackerid() const;
  void _internal_set_attackerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Die)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 objectid_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Connected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Connected) */ {
 public:
  inline S_Connected() : S_Connected(nullptr) {}
  ~S_Connected() override;
  explicit constexpr S_Connected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Connected(const S_Connected& from);
  S_Connected(S_Connected&& from) noexcept
    : S_Connected() {
    *this = ::std::move(from);
  }

  inline S_Connected& operator=(const S_Connected& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Connected& operator=(S_Connected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Connected& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Connected* internal_default_instance() {
    return reinterpret_cast<const S_Connected*>(
               &_S_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_Connected& a, S_Connected& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Connected* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Connected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Connected* New() const final {
    return new S_Connected();
  }

  S_Connected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Connected>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Connected& from);
  void MergeFrom(const S_Connected& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Connected* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Connected";
  }
  protected:
  explicit S_Connected(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Connected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  explicit constexpr C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Login* New() const final {
    return new C_Login();
  }

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Login& from);
  void MergeFrom(const C_Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string Id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit constexpr S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Login* New() const final {
    return new S_Login();
  }

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Login& from);
  void MergeFrom(const S_Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 2,
    kLoginOkFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // int32 loginOk = 1;
  void clear_loginok();
  ::PROTOBUF_NAMESPACE_ID::int32 loginok() const;
  void set_loginok(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_loginok() const;
  void _internal_set_loginok(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  ::PROTOBUF_NAMESPACE_ID::int32 loginok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterGame) */ {
 public:
  inline C_EnterGame() : C_EnterGame(nullptr) {}
  ~C_EnterGame() override;
  explicit constexpr C_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterGame(const C_EnterGame& from);
  C_EnterGame(C_EnterGame&& from) noexcept
    : C_EnterGame() {
    *this = ::std::move(from);
  }

  inline C_EnterGame& operator=(const C_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterGame& operator=(C_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterGame* internal_default_instance() {
    return reinterpret_cast<const C_EnterGame*>(
               &_C_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_EnterGame& a, C_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_EnterGame* New() const final {
    return new C_EnterGame();
  }

  C_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_EnterGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_EnterGame& from);
  void MergeFrom(const C_EnterGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterGame";
  }
  protected:
  explicit C_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeStat) */ {
 public:
  inline S_ChangeStat() : S_ChangeStat(nullptr) {}
  ~S_ChangeStat() override;
  explicit constexpr S_ChangeStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeStat(const S_ChangeStat& from);
  S_ChangeStat(S_ChangeStat&& from) noexcept
    : S_ChangeStat() {
    *this = ::std::move(from);
  }

  inline S_ChangeStat& operator=(const S_ChangeStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeStat& operator=(S_ChangeStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeStat* internal_default_instance() {
    return reinterpret_cast<const S_ChangeStat*>(
               &_S_ChangeStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_ChangeStat& a, S_ChangeStat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeStat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ChangeStat* New() const final {
    return new S_ChangeStat();
  }

  S_ChangeStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ChangeStat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ChangeStat& from);
  void MergeFrom(const S_ChangeStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeStat";
  }
  protected:
  explicit S_ChangeStat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatInfoFieldNumber = 1,
  };
  // .Protocol.StatInfo statInfo = 1;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::StatInfo* statinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Chat) */ {
 public:
  inline C_Chat() : C_Chat(nullptr) {}
  ~C_Chat() override;
  explicit constexpr C_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Chat(const C_Chat& from);
  C_Chat(C_Chat&& from) noexcept
    : C_Chat() {
    *this = ::std::move(from);
  }

  inline C_Chat& operator=(const C_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Chat& operator=(C_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Chat* internal_default_instance() {
    return reinterpret_cast<const C_Chat*>(
               &_C_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_Chat& a, C_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Chat* New() const final {
    return new C_Chat();
  }

  C_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Chat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Chat& from);
  void MergeFrom(const C_Chat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Chat";
  }
  protected:
  explicit C_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Chat) */ {
 public:
  inline S_Chat() : S_Chat(nullptr) {}
  ~S_Chat() override;
  explicit constexpr S_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Chat(const S_Chat& from);
  S_Chat(S_Chat&& from) noexcept
    : S_Chat() {
    *this = ::std::move(from);
  }

  inline S_Chat& operator=(const S_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Chat& operator=(S_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Chat* internal_default_instance() {
    return reinterpret_cast<const S_Chat*>(
               &_S_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_Chat& a, S_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Chat* New() const final {
    return new S_Chat();
  }

  S_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Chat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Chat& from);
  void MergeFrom(const S_Chat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Chat";
  }
  protected:
  explicit S_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kObjectIdFieldNumber = 1,
  };
  // string userName = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 objectId = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::int32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_objectid() const;
  void _internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CreateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CreateAccount) */ {
 public:
  inline C_CreateAccount() : C_CreateAccount(nullptr) {}
  ~C_CreateAccount() override;
  explicit constexpr C_CreateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreateAccount(const C_CreateAccount& from);
  C_CreateAccount(C_CreateAccount&& from) noexcept
    : C_CreateAccount() {
    *this = ::std::move(from);
  }

  inline C_CreateAccount& operator=(const C_CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreateAccount& operator=(C_CreateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreateAccount* internal_default_instance() {
    return reinterpret_cast<const C_CreateAccount*>(
               &_C_CreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_CreateAccount& a, C_CreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreateAccount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_CreateAccount* New() const final {
    return new C_CreateAccount();
  }

  C_CreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_CreateAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_CreateAccount& from);
  void MergeFrom(const C_CreateAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CreateAccount";
  }
  protected:
  explicit C_CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kNickNameFieldNumber = 3,
  };
  // string Id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string nickName = 3;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CreateAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CreateAccount) */ {
 public:
  inline S_CreateAccount() : S_CreateAccount(nullptr) {}
  ~S_CreateAccount() override;
  explicit constexpr S_CreateAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreateAccount(const S_CreateAccount& from);
  S_CreateAccount(S_CreateAccount&& from) noexcept
    : S_CreateAccount() {
    *this = ::std::move(from);
  }

  inline S_CreateAccount& operator=(const S_CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreateAccount& operator=(S_CreateAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreateAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreateAccount* internal_default_instance() {
    return reinterpret_cast<const S_CreateAccount*>(
               &_S_CreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_CreateAccount& a, S_CreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreateAccount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_CreateAccount* New() const final {
    return new S_CreateAccount();
  }

  S_CreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_CreateAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_CreateAccount& from);
  void MergeFrom(const S_CreateAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CreateAccount";
  }
  protected:
  explicit S_CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Ping) */ {
 public:
  inline S_Ping() : S_Ping(nullptr) {}
  ~S_Ping() override;
  explicit constexpr S_Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Ping(const S_Ping& from);
  S_Ping(S_Ping&& from) noexcept
    : S_Ping() {
    *this = ::std::move(from);
  }

  inline S_Ping& operator=(const S_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Ping& operator=(S_Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Ping* internal_default_instance() {
    return reinterpret_cast<const S_Ping*>(
               &_S_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_Ping& a, S_Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Ping* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Ping* New() const final {
    return new S_Ping();
  }

  S_Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Ping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Ping& from);
  void MergeFrom(const S_Ping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Ping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Ping";
  }
  protected:
  explicit S_Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Pong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Pong) */ {
 public:
  inline C_Pong() : C_Pong(nullptr) {}
  ~C_Pong() override;
  explicit constexpr C_Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Pong(const C_Pong& from);
  C_Pong(C_Pong&& from) noexcept
    : C_Pong() {
    *this = ::std::move(from);
  }

  inline C_Pong& operator=(const C_Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Pong& operator=(C_Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Pong* internal_default_instance() {
    return reinterpret_cast<const C_Pong*>(
               &_C_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(C_Pong& a, C_Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Pong* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Pong* New() const final {
    return new C_Pong();
  }

  C_Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Pong>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Pong& from);
  void MergeFrom(const C_Pong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Pong* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Pong";
  }
  protected:
  explicit C_Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_EnterGame

// .Protocol.ObjectInfo player = 1;
inline bool S_EnterGame::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_EnterGame::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_EnterGame::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_EnterGame::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.player)
  return _internal_player();
}
inline void S_EnterGame::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_EnterGame.player)
}
inline ::Protocol::ObjectInfo* S_EnterGame::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_EnterGame.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_EnterGame::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_EnterGame.player)
  return _internal_mutable_player();
}
inline void S_EnterGame::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_EnterGame.player)
}

// -------------------------------------------------------------------

// S_LeaveGame

// -------------------------------------------------------------------

// S_Spawn

// repeated .Protocol.ObjectInfo objects = 1;
inline int S_Spawn::_internal_objects_size() const {
  return objects_.size();
}
inline int S_Spawn::objects_size() const {
  return _internal_objects_size();
}
inline ::Protocol::ObjectInfo* S_Spawn::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Spawn.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_Spawn::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Spawn.objects)
  return &objects_;
}
inline const ::Protocol::ObjectInfo& S_Spawn::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_Spawn::objects(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Spawn.objects)
  return _internal_objects(index);
}
inline ::Protocol::ObjectInfo* S_Spawn::_internal_add_objects() {
  return objects_.Add();
}
inline ::Protocol::ObjectInfo* S_Spawn::add_objects() {
  // @@protoc_insertion_point(field_add:Protocol.S_Spawn.objects)
  return _internal_add_objects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_Spawn::objects() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Spawn.objects)
  return objects_;
}

// -------------------------------------------------------------------

// S_Despawn

// repeated int32 objectIds = 1;
inline int S_Despawn::_internal_objectids_size() const {
  return objectids_.size();
}
inline int S_Despawn::objectids_size() const {
  return _internal_objectids_size();
}
inline void S_Despawn::clear_objectids() {
  objectids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Despawn::_internal_objectids(int index) const {
  return objectids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Despawn::objectids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Despawn.objectIds)
  return _internal_objectids(index);
}
inline void S_Despawn::set_objectids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  objectids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_Despawn.objectIds)
}
inline void S_Despawn::_internal_add_objectids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  objectids_.Add(value);
}
inline void S_Despawn::add_objectids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_objectids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_Despawn.objectIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
S_Despawn::_internal_objectids() const {
  return objectids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
S_Despawn::objectids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Despawn.objectIds)
  return _internal_objectids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
S_Despawn::_internal_mutable_objectids() {
  return &objectids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
S_Despawn::mutable_objectids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Despawn.objectIds)
  return _internal_mutable_objectids();
}

// -------------------------------------------------------------------

// C_Move

// .Protocol.PositionInfo posInfo = 1;
inline bool C_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool C_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& C_Move::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Move.posInfo)
  return _internal_posinfo();
}
inline void C_Move::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_Move.posInfo)
}
inline ::Protocol::PositionInfo* C_Move::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PositionInfo* C_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_Move.posInfo)
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_Move::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PositionInfo* C_Move::mutable_posinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Move.posInfo)
  return _internal_mutable_posinfo();
}
inline void C_Move::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Move.posInfo)
}

// -------------------------------------------------------------------

// S_Move

// int32 objectId = 1;
inline void S_Move::clear_objectid() {
  objectid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Move::_internal_objectid() const {
  return objectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Move::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.objectId)
  return _internal_objectid();
}
inline void S_Move::_internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  objectid_ = value;
}
inline void S_Move::set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Move.objectId)
}

// .Protocol.PositionInfo posInfo = 2;
inline bool S_Move::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool S_Move::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& S_Move::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_Move::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.posInfo)
  return _internal_posinfo();
}
inline void S_Move::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Move.posInfo)
}
inline ::Protocol::PositionInfo* S_Move::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::PositionInfo* S_Move::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_Move.posInfo)
  
  ::Protocol::PositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_Move::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PositionInfo* S_Move::mutable_posinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Move.posInfo)
  return _internal_mutable_posinfo();
}
inline void S_Move::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Move.posInfo)
}

// -------------------------------------------------------------------

// C_Skill

// .Protocol.SkillInfo info = 1;
inline bool C_Skill::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool C_Skill::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::SkillInfo& C_Skill::_internal_info() const {
  const ::Protocol::SkillInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& C_Skill::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Skill.info)
  return _internal_info();
}
inline void C_Skill::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_Skill.info)
}
inline ::Protocol::SkillInfo* C_Skill::release_info() {
  
  ::Protocol::SkillInfo* temp = info_;
  info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::SkillInfo* C_Skill::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_Skill.info)
  
  ::Protocol::SkillInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* C_Skill::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::Protocol::SkillInfo* C_Skill::mutable_info() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Skill.info)
  return _internal_mutable_info();
}
inline void C_Skill::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Skill.info)
}

// -------------------------------------------------------------------

// S_Skill

// int32 objectId = 1;
inline void S_Skill::clear_objectid() {
  objectid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Skill::_internal_objectid() const {
  return objectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Skill::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Skill.objectId)
  return _internal_objectid();
}
inline void S_Skill::_internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  objectid_ = value;
}
inline void S_Skill::set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Skill.objectId)
}

// .Protocol.SkillInfo info = 2;
inline bool S_Skill::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool S_Skill::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::SkillInfo& S_Skill::_internal_info() const {
  const ::Protocol::SkillInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& S_Skill::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Skill.info)
  return _internal_info();
}
inline void S_Skill::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Skill.info)
}
inline ::Protocol::SkillInfo* S_Skill::release_info() {
  
  ::Protocol::SkillInfo* temp = info_;
  info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::SkillInfo* S_Skill::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_Skill.info)
  
  ::Protocol::SkillInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* S_Skill::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::Protocol::SkillInfo* S_Skill::mutable_info() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Skill.info)
  return _internal_mutable_info();
}
inline void S_Skill::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Skill.info)
}

// -------------------------------------------------------------------

// S_ChangeHp

// int32 objectId = 1;
inline void S_ChangeHp::clear_objectid() {
  objectid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_ChangeHp::_internal_objectid() const {
  return objectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_ChangeHp::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeHp.objectId)
  return _internal_objectid();
}
inline void S_ChangeHp::_internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  objectid_ = value;
}
inline void S_ChangeHp::set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeHp.objectId)
}

// int32 hp = 2;
inline void S_ChangeHp::clear_hp() {
  hp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_ChangeHp::_internal_hp() const {
  return hp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_ChangeHp::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeHp.hp)
  return _internal_hp();
}
inline void S_ChangeHp::_internal_set_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hp_ = value;
}
inline void S_ChangeHp::set_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeHp.hp)
}

// -------------------------------------------------------------------

// S_Die

// int32 objectId = 1;
inline void S_Die::clear_objectid() {
  objectid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Die::_internal_objectid() const {
  return objectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Die::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Die.objectId)
  return _internal_objectid();
}
inline void S_Die::_internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  objectid_ = value;
}
inline void S_Die::set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Die.objectId)
}

// int32 attackerId = 2;
inline void S_Die::clear_attackerid() {
  attackerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Die::_internal_attackerid() const {
  return attackerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Die::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Die.attackerId)
  return _internal_attackerid();
}
inline void S_Die::_internal_set_attackerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackerid_ = value;
}
inline void S_Die::set_attackerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Die.attackerId)
}

// -------------------------------------------------------------------

// S_Connected

// -------------------------------------------------------------------

// C_Login

// string Id = 1;
inline void C_Login::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_Login::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.Id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Login.Id)
}
inline std::string* C_Login::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Login.Id)
  return _internal_mutable_id();
}
inline const std::string& C_Login::_internal_id() const {
  return id_.Get();
}
inline void C_Login::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_Login.Id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Login.Id)
}

// string password = 2;
inline void C_Login::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& C_Login::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Login.password)
}
inline std::string* C_Login::mutable_password() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Login.password)
  return _internal_mutable_password();
}
inline const std::string& C_Login::_internal_password() const {
  return password_.Get();
}
inline void C_Login::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_Login.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Login.password)
}

// -------------------------------------------------------------------

// S_Login

// int32 loginOk = 1;
inline void S_Login::clear_loginok() {
  loginok_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Login::_internal_loginok() const {
  return loginok_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Login::loginok() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Login.loginOk)
  return _internal_loginok();
}
inline void S_Login::_internal_set_loginok(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  loginok_ = value;
}
inline void S_Login::set_loginok(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_loginok(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Login.loginOk)
}

// .Protocol.ObjectInfo player = 2;
inline bool S_Login::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_Login::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_Login::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_Login::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Login.player)
  return _internal_player();
}
inline void S_Login::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Login.player)
}
inline ::Protocol::ObjectInfo* S_Login::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_Login::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_Login.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_Login::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_Login::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Login.player)
  return _internal_mutable_player();
}
inline void S_Login::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Login.player)
}

// -------------------------------------------------------------------

// C_EnterGame

// string name = 1;
inline void C_EnterGame::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& C_EnterGame::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EnterGame.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_EnterGame::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_EnterGame.name)
}
inline std::string* C_EnterGame::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_EnterGame.name)
  return _internal_mutable_name();
}
inline const std::string& C_EnterGame::_internal_name() const {
  return name_.Get();
}
inline void C_EnterGame::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_EnterGame::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_EnterGame::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_EnterGame.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_EnterGame::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_EnterGame.name)
}

// -------------------------------------------------------------------

// S_ChangeStat

// .Protocol.StatInfo statInfo = 1;
inline bool S_ChangeStat::_internal_has_statinfo() const {
  return this != internal_default_instance() && statinfo_ != nullptr;
}
inline bool S_ChangeStat::has_statinfo() const {
  return _internal_has_statinfo();
}
inline const ::Protocol::StatInfo& S_ChangeStat::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& S_ChangeStat::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeStat.statInfo)
  return _internal_statinfo();
}
inline void S_ChangeStat::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo_);
  }
  statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ChangeStat.statInfo)
}
inline ::Protocol::StatInfo* S_ChangeStat::release_statinfo() {
  
  ::Protocol::StatInfo* temp = statinfo_;
  statinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::StatInfo* S_ChangeStat::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ChangeStat.statInfo)
  
  ::Protocol::StatInfo* temp = statinfo_;
  statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* S_ChangeStat::_internal_mutable_statinfo() {
  
  if (statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    statinfo_ = p;
  }
  return statinfo_;
}
inline ::Protocol::StatInfo* S_ChangeStat::mutable_statinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ChangeStat.statInfo)
  return _internal_mutable_statinfo();
}
inline void S_ChangeStat::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo_);
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo));
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ChangeStat.statInfo)
}

// -------------------------------------------------------------------

// C_Chat

// string message = 1;
inline void C_Chat::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& C_Chat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Chat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Chat::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Chat.message)
}
inline std::string* C_Chat::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Chat.message)
  return _internal_mutable_message();
}
inline const std::string& C_Chat::_internal_message() const {
  return message_.Get();
}
inline void C_Chat::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Chat::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Chat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.C_Chat.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Chat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Chat.message)
}

// -------------------------------------------------------------------

// S_Chat

// int32 objectId = 1;
inline void S_Chat::clear_objectid() {
  objectid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Chat::_internal_objectid() const {
  return objectid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 S_Chat::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Chat.objectId)
  return _internal_objectid();
}
inline void S_Chat::_internal_set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  objectid_ = value;
}
inline void S_Chat::set_objectid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Chat.objectId)
}

// string userName = 2;
inline void S_Chat::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& S_Chat::username() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Chat.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_Chat::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_Chat.userName)
}
inline std::string* S_Chat::mutable_username() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Chat.userName)
  return _internal_mutable_username();
}
inline const std::string& S_Chat::_internal_username() const {
  return username_.Get();
}
inline void S_Chat::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_Chat::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_Chat::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.S_Chat.userName)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_Chat::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Chat.userName)
}

// string message = 3;
inline void S_Chat::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& S_Chat::message() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Chat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_Chat::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_Chat.message)
}
inline std::string* S_Chat::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Chat.message)
  return _internal_mutable_message();
}
inline const std::string& S_Chat::_internal_message() const {
  return message_.Get();
}
inline void S_Chat::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_Chat::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_Chat::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.S_Chat.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_Chat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Chat.message)
}

// -------------------------------------------------------------------

// C_CreateAccount

// string Id = 1;
inline void C_CreateAccount::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_CreateAccount::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateAccount.Id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateAccount::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateAccount.Id)
}
inline std::string* C_CreateAccount::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateAccount.Id)
  return _internal_mutable_id();
}
inline const std::string& C_CreateAccount::_internal_id() const {
  return id_.Get();
}
inline void C_CreateAccount::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateAccount.Id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CreateAccount::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateAccount.Id)
}

// string password = 2;
inline void C_CreateAccount::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& C_CreateAccount::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateAccount.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateAccount::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateAccount.password)
}
inline std::string* C_CreateAccount::mutable_password() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateAccount.password)
  return _internal_mutable_password();
}
inline const std::string& C_CreateAccount::_internal_password() const {
  return password_.Get();
}
inline void C_CreateAccount::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateAccount.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CreateAccount::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateAccount.password)
}

// string nickName = 3;
inline void C_CreateAccount::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& C_CreateAccount::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateAccount.nickName)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateAccount::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateAccount.nickName)
}
inline std::string* C_CreateAccount::mutable_nickname() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateAccount.nickName)
  return _internal_mutable_nickname();
}
inline const std::string& C_CreateAccount::_internal_nickname() const {
  return nickname_.Get();
}
inline void C_CreateAccount::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_CreateAccount::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateAccount.nickName)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_CreateAccount::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateAccount.nickName)
}

// -------------------------------------------------------------------

// S_CreateAccount

// bool success = 1;
inline void S_CreateAccount::clear_success() {
  success_ = false;
}
inline bool S_CreateAccount::_internal_success() const {
  return success_;
}
inline bool S_CreateAccount::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateAccount.success)
  return _internal_success();
}
inline void S_CreateAccount::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_CreateAccount::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CreateAccount.success)
}

// -------------------------------------------------------------------

// S_Ping

// -------------------------------------------------------------------

// C_Pong

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
